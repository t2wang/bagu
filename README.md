### Springboot相对于Spring的优势

```
1. 简化的配置
Spring Boot通过自动配置的机制，大大简化了应用程序的配置过程。它根据应用程序的依赖和环境自动配置各种组件，无需手动配置大量的XML文件或Java类。这样，开发人员可以更专注于业务逻辑的实现，而不需要花费太多时间和精力在配置上。

2. 内嵌的服务器
Spring Boot提供了内嵌的服务器，如Tomcat、Jetty等。这意味着我们无需部署WAR文件到独立的服务器上，而是可以直接将应用程序打包成可执行的JAR文件，并通过命令行或脚本启动应用程序。这样，我们可以更方便地进行开发、测试和部署。

3. 自动依赖管理
Spring Boot通过自动依赖管理，可以自动管理应用程序的依赖关系。它会根据应用程序的需要自动引入所需的依赖，并解决依赖冲突的问题。这样，我们无需手动管理依赖关系，减少了开发人员的工作量。

4. 简化的开发流程
Spring Boot提供了一套简化的开发流程，使得开发人员可以快速搭建和开发应用程序。它提供了一些常用的功能和组件，如数据库访问、Web开发、安全性等，可以快速集成到应用程序中。这样，我们可以更快速地开发出高质量的应用程序。

5. 监控和管理
Spring Boot提供了一些监控和管理的功能，如健康检查、指标收集、日志记录等。这些功能可以帮助我们更好地监控和管理应用程序的运行状态，及时发现和解决问题。

6. 生态系统
Spring Boot是Spring生态系统的一部分，与其他Spring项目（如Spring MVC、Spring Data等）无缝集成。这意味着我们可以利用Spring的丰富生态系统来构建更加强大和灵活的应用程序。
综上所述，Spring Boot相对于Spring框架具有简化的配置、内嵌的服务器、自动依赖管理、简化的开发流程、监控和管理功能以及丰富的生态系统等优点。这些优点使得Spring Boot成为开发Java应用程序的理想选择，能够提高开发效率和代码质量。
```

### 线程池默认更适合CPU密集型场景还是IO密集型场景

```
JDK线程池
JDK 实现的这个线程池优先把任务放入队列暂存起来，而不是创建更多的线程，它比较适用于执行 CPU 密集型的任务，也就是需要执行大量 CPU 运算的任务。这是为什么呢？因为执行 CPU 密集型的任务时 CPU 比较繁忙，因此只需要创建和 CPU 核数相当的线程就好了，多了反而会造成线程上下文切换，降低任务执行效率。所以当前线程数超过核心线程数时，线程池不会增加线程，而是放在队列里等待核心线程空闲下来。

Tomcat线程池
我们平时开发的 Web 系统通常都有大量的 IO 操作，比方说查询数据库、查询缓存等等。任务在执行 IO 操作的时候 CPU 就空闲了下来，这时如果增加执行任务的线程数而不是把任务暂存在队列中，就可以在单位时间内执行更多的任务，大大提高了任务执行的吞吐量。所以Tomcat 使用的线程池对 JDK 原生的线程池做了一些改造，当线程数超过 coreThreadCount 之后会优先创建线程，直到线程数到达 maxThreadCount
```

### Redis过期删除策略

### Mybatisplus相比于Mybatis的优势是什么

```
1. 提供了分页插件，开发者无需关心具体操作，配置好插件之后，写分页等同于普通List查询。

2. 提供了代码生成器，可以通过代码来自动快速生成Mapper、Model、Service、Controller层代码，大大减少了开发者的开发量。

3. 支持全局通用方法注入，可以减少重复的代码编写。

4. 提供了多种主键策略，支持多达4种主键策略（内含分布式唯一ID生成器），可自由配置，完美解决主键问题。

5. 支持关键词自动转义，支持数据库关键词（order、key…）自动转义，还可自定义关键词。
```

### Mybatis配置文件中#{}和${}传参区别是什么

```
#传入的参数在SQL中显示为字符串，能够很大程度防止sql注入；
$传入的参数在SqL中直接显示为传入的值，无法防止Sql注入。
```

### Java中long的是原子性？

```
对于32位操作系统来说，单次次操作能处理的最长长度为32bit，而long类型8字节64bit，所以对long的读写都要两条指令才能完成（即每次读写64bit中的32bit）

对于64位的long和double，如果没有被volatile修饰，那么对其操作可以不是原子的。在操作的时候，可以分成两步，每次对32位操作。
如果使用volatile修饰long和double，那么其读写都是原子操作
对于64位的引用地址的读写，都是原子操作
在实现JVM时，可以自由选择是否把读写long和double作为原子操作
推荐JVM实现为原子操作

对于64bit的环境来说，单次操作可以操作64bit的数据，即可以以一次性读写long或double的整个64bit。因此我们可以猜测，在64位的环境下，long和double的读写有可能是原子操作。 在换了64位的JVM之后，多次运行，结果都是正确的
```

### Golang和Java的区别

```
1.性能上： golang的性能比Java更好，占用内存更少，使用goroutine避免内核态和用户态切换成本。

2.编译部署:Java通过虚拟机编译，使用JVM跨平台编译；Go中不存在虚拟机,针对不同的平台，编译对应的机器码；

3.访问权限: java使用public、protected、private、默认等关键字；golang通过大小写控制。

4.接口: java等面向对象编程的接口是侵入式接口，需要明确声明自己实现了某个接口；而Golang的非侵入式接口不需要通过任何关键字，只要一个类型实现了接口的所有方法，就是这个接口的实现。

5.异常处理:java中错误（Error）和异常(Exception)被分类管理，golang中只有error，一旦发生错误逐层返回，直到被处理。
Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。

6.继承:Java的继承通过extends关键字完成，不支持多继承；Go语言的继承通过Struct的方式，子类只需要把基类作为成员放在子类的定义中，支持多继承。

7.多态:java的多态，必须满足继承，重写，向上转型；在Go语言中通过接口实现多态，对接口的实现只需要某个类型T实现了接口中的方法，就相当于实现了该接口。

8.值传递和引用传递:java中不存在显式的指针，而Golang中存在显式的指针操作。java和golang都是只存在值传递。

9.并发:在Java中，通常借助于共享内存（全局变量）作为线程间通信的媒介，通常会有线程不安全问题，使用了加锁（同步化）、使用原子类、使用volatile提升可见性等解决；但在Golang中使用的是通道（channel）作为协程间通信的媒介，多个goroutine之间通过Channel来通信，chan的读取和写入操作为原子操作，所以是安全的。

10.垃圾回收和内存管理机制:Java基于JVM虚拟机的分代收集算法完成GC，golang内存释放语言层面，对不再使用的内存资源进行自动回收，多级缓存，非分代，并发的三色标记算法。
```

### 大根堆小根堆如何实现

```
小顶堆的实现：
1. 可以使用数组来实现小顶堆，数组中的第一个元素为堆顶，依次往后排列。对于任意位置i的元素，其父节点为(i-1)/2，左子节点为2*i+1，右子节点为2*i+2。

2. 插入元素时，先将元素插入到堆的最后一个位置，然后将其与父节点比较，如果比父节点小，则交换位置，直到满足小顶堆的性质。

3. 删除堆顶元素时，将堆顶元素与最后一个元素交换位置，然后删除最后一个元素。再从堆顶开始，与其子节点比较，如果比子节点大，则与较小的子节点交换位置，直到满足小顶堆的性质。

大顶堆的实现：
1. 大顶堆的实现方式与小顶堆基本相同，只是在比较元素大小的时候相反。即插入元素时，如果比父节点大，则交换位置，删除堆顶元素时，如果比子节点小，则与较大的子节点交换位置。
```

### 哈希表如何解决哈希冲突

```
哈希表在插入元素时，如果计算出的哈希值已经有元素存在，就会发生哈希冲突。为了解决这个问题，可以采用开放寻址法和链地址法。开放寻址法是在发生冲突时，不断探测下一个空的位置来插入元素；链地址法则是在哈希表中每个槽位上维护一个链表或者其他数据结构，将哈希值相同的元素放在同一个槽位上。
```

### 浏览器从输入URL到展示页面，经历了哪些过程？

```
1. 浏览器解析url：浏览器会对我们输入的url进行解析，主要将其分为下部分：协议、网络地址、资源路径。其中网络地址指示该连接网络上哪一台计算机，可以是域名或者IP地址，可以包括端口号；协议是从该计算机获取资源的方式，常见的是HTTP，HTTPS，FTP等。不同协议有不同的通讯内容格式；资源路径指示从服务器上需要获取资源的具体路径。

2. 客户端收到你输入的域名地址后，它首先去找本地的hosts文件，检查在该文件中是否有相应的域名、IP对应关系，如果有，则向其IP地址发送请求，如果没有，再去找DNS服务器。

2.1. DNS查询的具体步骤如下：

    从浏览器缓存中查询。浏览器会存储一定时间的DNS记录，操作系统不会告诉浏览器每个DNS记录的保存时限，不同浏览器设置保存时限为一个固定值（不同浏览器情况不同，一般在2-30分钟）。

    从操作系统缓存中查询。如果浏览器中没有包含想要的缓存记录，那浏览器就会发起操作系统请求，继续查询操作系统缓存

    从路由器中查询DNS缓存。请求持续发送到你的路由，它通常会有自己的DNS缓存。
    
    从ISP中查询DNS缓存。下一个被查询地方是ISP缓存DNS的服务器。
    
    域名服务器迭代查询，根据返回的地址逐级向上查询。首先从root域名服务器中查询如.com域名服务器，然后逐步向前查询，.com顶级域名服务器到ruanyifeng的域名服务器。一般来说，.com级别的都已经在缓存中了，所以一般不会进行对root域名服务器的查询。

3. 浏览器获取端口号: http默认80端口，https默认443端口

4. TCP建立连接：三次握手完成，TCP客户端和服务器端成功地建立连接，可以开始传输数据了。

4.1. TCP三次握手的过程如下：

    客户端发送SYN（SEQ=x）报文给服务器端，进入SYN_SEND状态。

    服务器端收到SYN报文，回应一个SYN （SEQ=y）ACK(ACK=x+1）报文，进入SYN_RECV状态。

    客户端收到服务器端的SYN报文，回应一个ACK(ACK=y+1）报文，进入Established状态。

5. 发送HTTP请求

6. 服务器处理请求：服务器端收到请求后的由web服务器（准确说应该是http服务器）处理请求，诸如Apache、Ngnix、IIS等。web服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。

7. 返回响应结果

8. 关闭TCP连接

8.1. TCP四次握手

    某个应用进程首先调用close，称该端执行“主动关闭”（active close）。该端的TCP于是发送一个FIN分节，表示数据发送完毕。
    
    接收到这个FIN的对端执行 “被动关闭”（passive close），这个FIN由TCP确认。
    注意：FIN的接收也作为一个文件结束符（end-of-file）传递给接收端应用进程，放在已排队等候该应用进程接收的任何其他数据之后，因为，FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。
    
    一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN。
    
    接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）确认这个FIN。

9. 浏览器加载解析渲染：当浏览器获得一个html文件时，会“自上而下”加载，并在加载过程中进行解析渲染。

    浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。
    将CSS解析成 CSS Rule Tree 。
    根据DOM树和CSSOM来构造 Rendering Tree。

10. 浏览器发送嵌入在HTML中的对象的请求
```

### Mysql的索引在什么时候会失效

```
当我们在查询条件中对索引列使用函数，就会导致索引失效。

当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。

MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。
```

### 单例模式

```
public class Singleton {
    private volatile static Singleton singleton;

    private Singleton() {} 

    public static getSingleton() {
        if (singleton == null) {
            synchronized (Singleton.class) {
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }

        return singleton;
    }
}
```

### 幂等是什么，如何保证

```
同一个接口，多次发出同一个请求，必须保证操作只执行一次 

按钮只可操作一次：一般是提交后把按钮置灰或 loding 状态,消除用户因为重复点击而产生的重复记录,比如添加操作,由于点击两次而产生两条记录。

token机制：功能上允许重复提交,但要保证重复提交不产生副作用,比如点击 n 次只产生一条记录,具体实现就是进入页面时申请一个 token,然后后面所有的请求都带上这个 token,后端根据 token 来避免重复请求。

使用唯一索引防止新增脏数据：利用数据库唯一索引机制,当数据重复时,插入数据库会抛出异常,保证不会出现脏数据。

乐观锁：如果更新已有数据,可以进行加锁更新,也可以设计表结构时使用乐观锁,通过 version 来做乐观锁,这样既能保证执行效率,又能保证幂等, 乐观锁的 version 版本在更新业务数据要自增。
```

### jvm内存区域

```
JVM把虚拟机的内存区域划分为方法区（Method Area）、堆（Heap）、栈（Java Stack）、本地方法栈（Native Method Stack）、和一个PC寄存器（程序计数器，Progam Counting Register）。

    栈是计算机内存中的一个用于处理函数调用和局部变量存储的数据结构。它是操作系统或虚拟机为每个线程分配的一块内存空间，用于存储函数调用时相关的信息。
    当一个函数被调用时，栈会分配一片内存区域来存储该函数的局部变量、参数和返回地址等信息。这些信息会按照特定的格式被依次压入栈中。随着函数的执行结束，栈中的数据会被逐个弹出，恢复到调用该函数的上下文环境。
    栈具有"先进后出"的特点，也就是最后进入栈的数据会最先被处理。栈上的数据按照严格的顺序操作，保证了函数调用在执行过程中的正确性和完整性。

    堆是计算机内存中的一块动态分配的内存区域，用于存储程序运行时创建的对象和数据。
    堆的管理通常使用一种称为"垃圾回收"的机制，它会自动识别不再使用的对象，并将其空间回收，以便重新利用。

    方法区，也称为永久代，是一种用于存储类的元数据（Metadata）和静态变量的内存区域。它是虚拟机中的一部分，用于保存类信息、常量、静态变量、即时编译器编译后的代码等数据。
    需要注意的是，从Java 8开始，永久代（Permanent Generation）被移除，取而代之的是元空间（Metaspace），它使用本机内存来存储元数据和类信息。元空间的大小可以根据需要进行自动调整，不再受限于固定大小的永久代。

    程序计数器又称指令计数器（Instruction Counter）或程序指针（Program Pointer），是一种用于指示正在执行的程序的指令位置的寄存器。
    程序计数器是CPU中的一个独立寄存器，它保存着当前正在执行的指令的地址。每当CPU从内存中取出一条指令并执行时，程序计数器的值就会自动增加，指向下一条即将执行的指令的地址。也就是说，程序计数器跟踪着CPU下一条将要执行的指令的位置。它还具有保存返回地址和支持循环等功能。
    需要注意的是，程序计数器是一个较小的寄存器，它的大小取决于计算机体系结构的位数。例如，在32位架构中，程序计数器通常是一个32位的寄存器，可以表示2^32个内存地址。当程序计数器达到最大值时，将发生溢出并重新从0开始计数。

    本地方法栈是Java虚拟机中用于支持本地方法调用的一块内存区域，与虚拟机栈相对应。它承担着管理本地方法的调用和返回的任务，保存了本地方法的状态信息，包括方法的参数、局部变量和返回值。通过本地方法栈，Java程序可以与底层的本地代码进行交互和调用。本地方法是指在Java代码中调用的由底层语言（如C或C++）编写的方法。
    需要注意的是，本地方法栈与虚拟机栈之间是相互独立的，它们分别用于支持Java方法和本地方法的调用。在Java程序中，当调用本地方法时，JVM会通过本地方法栈进行跳转和管理。本地方法栈的生命周期和线程的生命周期一致，当线程结束时，对应的本地方法栈也会被销毁。
```

### HashMap和Hashtable的区别

```
1. 两者最主要的区别在于Hashtable是线程安全，而HashMap则非线程安全
2. HashMap可以使用null作为key，而Hashtable则不允许null作为key
3. HashMap是对Map接口的实现，HashTable实现了Map接口和Dictionary抽象类
4. HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75
5. 两者计算hash的方法不同
```

### HashSet和HashMap、Hashtable的区别

```
1. HashSet不是key value结构，仅仅是存储不重复的元素，相当于简化版的HashMap，只是包含HashMap中的key而已
2. HashSet内部就是使用HashMap实现，只不过HashSet里面的HashMap所有的value都是同一个Object而已，因此HashSet也是非线程安全的
```