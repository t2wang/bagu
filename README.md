### Springboot相对于Spring的优势

```
1. 简化的配置
Spring Boot通过自动配置的机制，大大简化了应用程序的配置过程。它根据应用程序的依赖和环境自动配置各种组件，无需手动配置大量的XML文件或Java类。这样，开发人员可以更专注于业务逻辑的实现，而不需要花费太多时间和精力在配置上。

2. 内嵌的服务器
Spring Boot提供了内嵌的服务器，如Tomcat、Jetty等。这意味着我们无需部署WAR文件到独立的服务器上，而是可以直接将应用程序打包成可执行的JAR文件，并通过命令行或脚本启动应用程序。这样，我们可以更方便地进行开发、测试和部署。

3. 自动依赖管理
Spring Boot通过自动依赖管理，可以自动管理应用程序的依赖关系。它会根据应用程序的需要自动引入所需的依赖，并解决依赖冲突的问题。这样，我们无需手动管理依赖关系，减少了开发人员的工作量。

4. 简化的开发流程
Spring Boot提供了一套简化的开发流程，使得开发人员可以快速搭建和开发应用程序。它提供了一些常用的功能和组件，如数据库访问、Web开发、安全性等，可以快速集成到应用程序中。这样，我们可以更快速地开发出高质量的应用程序。

5. 监控和管理
Spring Boot提供了一些监控和管理的功能，如健康检查、指标收集、日志记录等。这些功能可以帮助我们更好地监控和管理应用程序的运行状态，及时发现和解决问题。

6. 生态系统
Spring Boot是Spring生态系统的一部分，与其他Spring项目（如Spring MVC、Spring Data等）无缝集成。这意味着我们可以利用Spring的丰富生态系统来构建更加强大和灵活的应用程序。
综上所述，Spring Boot相对于Spring框架具有简化的配置、内嵌的服务器、自动依赖管理、简化的开发流程、监控和管理功能以及丰富的生态系统等优点。这些优点使得Spring Boot成为开发Java应用程序的理想选择，能够提高开发效率和代码质量。
```

### 线程池默认更适合CPU密集型场景还是IO密集型场景

```
JDK线程池
JDK 实现的这个线程池优先把任务放入队列暂存起来，而不是创建更多的线程，它比较适用于执行 CPU 密集型的任务，也就是需要执行大量 CPU 运算的任务。这是为什么呢？因为执行 CPU 密集型的任务时 CPU 比较繁忙，因此只需要创建和 CPU 核数相当的线程就好了，多了反而会造成线程上下文切换，降低任务执行效率。所以当前线程数超过核心线程数时，线程池不会增加线程，而是放在队列里等待核心线程空闲下来。

Tomcat线程池
我们平时开发的 Web 系统通常都有大量的 IO 操作，比方说查询数据库、查询缓存等等。任务在执行 IO 操作的时候 CPU 就空闲了下来，这时如果增加执行任务的线程数而不是把任务暂存在队列中，就可以在单位时间内执行更多的任务，大大提高了任务执行的吞吐量。所以Tomcat 使用的线程池对 JDK 原生的线程池做了一些改造，当线程数超过 coreThreadCount 之后会优先创建线程，直到线程数到达 maxThreadCount
```

### Redis过期删除策略

### Mybatisplus相比于Mybatis的优势是什么

```
1. 提供了分页插件，开发者无需关心具体操作，配置好插件之后，写分页等同于普通List查询。
2. 提供了代码生成器，可以通过代码来自动快速生成Mapper、Model、Service、Controller层代码，大大减少了开发者的开发量。
3. 支持全局通用方法注入，可以减少重复的代码编写。
4. 提供了多种主键策略，支持多达4种主键策略（内含分布式唯一ID生成器），可自由配置，完美解决主键问题。
5. 支持关键词自动转义，支持数据库关键词（order、key…）自动转义，还可自定义关键词。
```

### Mybatis配置文件中#{}和${}传参区别是什么

```
#传入的参数在SQL中显示为字符串，能够很大程度防止sql注入；
$传入的参数在SqL中直接显示为传入的值，无法防止Sql注入。
```

### Java中long的是原子性？

```
对于32位操作系统来说，单次次操作能处理的最长长度为32bit，而long类型8字节64bit，所以对long的读写都要两条指令才能完成（即每次读写64bit中的32bit）

对于64位的long和double，如果没有被volatile修饰，那么对其操作可以不是原子的。在操作的时候，可以分成两步，每次对32位操作。
如果使用volatile修饰long和double，那么其读写都是原子操作
对于64位的引用地址的读写，都是原子操作
在实现JVM时，可以自由选择是否把读写long和double作为原子操作
推荐JVM实现为原子操作

对于64bit的环境来说，单次操作可以操作64bit的数据，即可以以一次性读写long或double的整个64bit。因此我们可以猜测，在64位的环境下，long和double的读写有可能是原子操作。 在换了64位的JVM之后，多次运行，结果都是正确的
```

### Golang和Java的区别

```
1.性能上： golang的性能比Java更好，占用内存更少，使用goroutine避免内核态和用户态切换成本。

2.编译部署:Java通过虚拟机编译，使用JVM跨平台编译；Go中不存在虚拟机,针对不同的平台，编译对应的机器码；

3.访问权限: java使用public、protected、private、默认等关键字；golang通过大小写控制。

4.接口: java等面向对象编程的接口是侵入式接口，需要明确声明自己实现了某个接口；而Golang的非侵入式接口不需要通过任何关键字，只要一个类型实现了接口的所有方法，就是这个接口的实现。

5.异常处理:java中错误（Error）和异常(Exception)被分类管理，golang中只有error，一旦发生错误逐层返回，直到被处理。
Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。

6.继承:Java的继承通过extends关键字完成，不支持多继承；Go语言的继承通过Struct的方式，子类只需要把基类作为成员放在子类的定义中，支持多继承。

7.多态:java的多态，必须满足继承，重写，向上转型；在Go语言中通过接口实现多态，对接口的实现只需要某个类型T实现了接口中的方法，就相当于实现了该接口。

8.值传递和引用传递:java中不存在显式的指针，而Golang中存在显式的指针操作。java和golang都是只存在值传递。

9.并发:在Java中，通常借助于共享内存（全局变量）作为线程间通信的媒介，通常会有线程不安全问题，使用了加锁（同步化）、使用原子类、使用volatile提升可见性等解决；但在Golang中使用的是通道（channel）作为协程间通信的媒介，多个goroutine之间通过Channel来通信，chan的读取和写入操作为原子操作，所以是安全的。

10.垃圾回收和内存管理机制:Java基于JVM虚拟机的分代收集算法完成GC，golang内存释放语言层面，对不再使用的内存资源进行自动回收，多级缓存，非分代，并发的三色标记算法。
```

### 大根堆小根堆如何实现

```
小顶堆的实现：
1. 可以使用数组来实现小顶堆，数组中的第一个元素为堆顶，依次往后排列。对于任意位置i的元素，其父节点为(i-1)/2，左子节点为2*i+1，右子节点为2*i+2。
2. 插入元素时，先将元素插入到堆的最后一个位置，然后将其与父节点比较，如果比父节点小，则交换位置，直到满足小顶堆的性质。
3. 删除堆顶元素时，将堆顶元素与最后一个元素交换位置，然后删除最后一个元素。再从堆顶开始，与其子节点比较，如果比子节点大，则与较小的子节点交换位置，直到满足小顶堆的性质。

大顶堆的实现：
1. 大顶堆的实现方式与小顶堆基本相同，只是在比较元素大小的时候相反。即插入元素时，如果比父节点大，则交换位置，删除堆顶元素时，如果比子节点小，则与较大的子节点交换位置。
```

### 哈希表如何解决哈希冲突

```
哈希表在插入元素时，如果计算出的哈希值已经有元素存在，就会发生哈希冲突。为了解决这个问题，可以采用开放寻址法和链地址法。开放寻址法是在发生冲突时，不断探测下一个空的位置来插入元素；链地址法则是在哈希表中每个槽位上维护一个链表或者其他数据结构，将哈希值相同的元素放在同一个槽位上。
```