### Springboot相对于Spring的优势

```
1. 简化的配置
Spring Boot通过自动配置的机制，大大简化了应用程序的配置过程。它根据应用程序的依赖和环境自动配置各种组件，无需手动配置大量的XML文件或Java类。这样，开发人员可以更专注于业务逻辑的实现，而不需要花费太多时间和精力在配置上。

2. 内嵌的服务器
Spring Boot提供了内嵌的服务器，如Tomcat、Jetty等。这意味着我们无需部署WAR文件到独立的服务器上，而是可以直接将应用程序打包成可执行的JAR文件，并通过命令行或脚本启动应用程序。这样，我们可以更方便地进行开发、测试和部署。

3. 自动依赖管理
Spring Boot通过自动依赖管理，可以自动管理应用程序的依赖关系。它会根据应用程序的需要自动引入所需的依赖，并解决依赖冲突的问题。这样，我们无需手动管理依赖关系，减少了开发人员的工作量。

4. 简化的开发流程
Spring Boot提供了一套简化的开发流程，使得开发人员可以快速搭建和开发应用程序。它提供了一些常用的功能和组件，如数据库访问、Web开发、安全性等，可以快速集成到应用程序中。这样，我们可以更快速地开发出高质量的应用程序。

5. 监控和管理
Spring Boot提供了一些监控和管理的功能，如健康检查、指标收集、日志记录等。这些功能可以帮助我们更好地监控和管理应用程序的运行状态，及时发现和解决问题。

6. 生态系统
Spring Boot是Spring生态系统的一部分，与其他Spring项目（如Spring MVC、Spring Data等）无缝集成。这意味着我们可以利用Spring的丰富生态系统来构建更加强大和灵活的应用程序。
综上所述，Spring Boot相对于Spring框架具有简化的配置、内嵌的服务器、自动依赖管理、简化的开发流程、监控和管理功能以及丰富的生态系统等优点。这些优点使得Spring Boot成为开发Java应用程序的理想选择，能够提高开发效率和代码质量。
```

### 线程池默认更适合CPU密集型场景还是IO密集型场景

```
JDK线程池
JDK 实现的这个线程池优先把任务放入队列暂存起来，而不是创建更多的线程，它比较适用于执行 CPU 密集型的任务，也就是需要执行大量 CPU 运算的任务。这是为什么呢？因为执行 CPU 密集型的任务时 CPU 比较繁忙，因此只需要创建和 CPU 核数相当的线程就好了，多了反而会造成线程上下文切换，降低任务执行效率。所以当前线程数超过核心线程数时，线程池不会增加线程，而是放在队列里等待核心线程空闲下来。

Tomcat线程池
我们平时开发的 Web 系统通常都有大量的 IO 操作，比方说查询数据库、查询缓存等等。任务在执行 IO 操作的时候 CPU 就空闲了下来，这时如果增加执行任务的线程数而不是把任务暂存在队列中，就可以在单位时间内执行更多的任务，大大提高了任务执行的吞吐量。所以Tomcat 使用的线程池对 JDK 原生的线程池做了一些改造，当线程数超过 coreThreadCount 之后会优先创建线程，直到线程数到达 maxThreadCount
```

### Redis过期删除策略

### Mybatisplus相比于Mybatis的优势是什么

```
1. 提供了分页插件，开发者无需关心具体操作，配置好插件之后，写分页等同于普通List查询。

2. 提供了代码生成器，可以通过代码来自动快速生成Mapper、Model、Service、Controller层代码，大大减少了开发者的开发量。

3. 支持全局通用方法注入，可以减少重复的代码编写。

4. 提供了多种主键策略，支持多达4种主键策略（内含分布式唯一ID生成器），可自由配置，完美解决主键问题。

5. 支持关键词自动转义，支持数据库关键词（order、key…）自动转义，还可自定义关键词。
```

### Mybatis配置文件中#{}和${}传参区别是什么

```
#传入的参数在SQL中显示为字符串，能够很大程度防止sql注入；
$传入的参数在SqL中直接显示为传入的值，无法防止Sql注入。
```

### Java中long的是原子性？

```
对于32位操作系统来说，单次次操作能处理的最长长度为32bit，而long类型8字节64bit，所以对long的读写都要两条指令才能完成（即每次读写64bit中的32bit）

对于64位的long和double，如果没有被volatile修饰，那么对其操作可以不是原子的。在操作的时候，可以分成两步，每次对32位操作。
如果使用volatile修饰long和double，那么其读写都是原子操作
对于64位的引用地址的读写，都是原子操作
在实现JVM时，可以自由选择是否把读写long和double作为原子操作
推荐JVM实现为原子操作

对于64bit的环境来说，单次操作可以操作64bit的数据，即可以以一次性读写long或double的整个64bit。因此我们可以猜测，在64位的环境下，long和double的读写有可能是原子操作。 在换了64位的JVM之后，多次运行，结果都是正确的
```

### Golang和Java的区别

```
1.性能上： golang的性能比Java更好，占用内存更少，使用goroutine避免内核态和用户态切换成本。

2.编译部署:Java通过虚拟机编译，使用JVM跨平台编译；Go中不存在虚拟机,针对不同的平台，编译对应的机器码；

3.访问权限: java使用public、protected、private、默认等关键字；golang通过大小写控制。

4.接口: java等面向对象编程的接口是侵入式接口，需要明确声明自己实现了某个接口；而Golang的非侵入式接口不需要通过任何关键字，只要一个类型实现了接口的所有方法，就是这个接口的实现。

5.异常处理:java中错误（Error）和异常(Exception)被分类管理，golang中只有error，一旦发生错误逐层返回，直到被处理。
Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。

6.继承:Java的继承通过extends关键字完成，不支持多继承；Go语言的继承通过Struct的方式，子类只需要把基类作为成员放在子类的定义中，支持多继承。

7.多态:java的多态，必须满足继承，重写，向上转型；在Go语言中通过接口实现多态，对接口的实现只需要某个类型T实现了接口中的方法，就相当于实现了该接口。

8.值传递和引用传递:java中不存在显式的指针，而Golang中存在显式的指针操作。java和golang都是只存在值传递。

9.并发:在Java中，通常借助于共享内存（全局变量）作为线程间通信的媒介，通常会有线程不安全问题，使用了加锁（同步化）、使用原子类、使用volatile提升可见性等解决；但在Golang中使用的是通道（channel）作为协程间通信的媒介，多个goroutine之间通过Channel来通信，chan的读取和写入操作为原子操作，所以是安全的。

10.垃圾回收和内存管理机制:Java基于JVM虚拟机的分代收集算法完成GC，golang内存释放语言层面，对不再使用的内存资源进行自动回收，多级缓存，非分代，并发的三色标记算法。
```

### 大根堆小根堆如何实现

```
小顶堆的实现：
1. 可以使用数组来实现小顶堆，数组中的第一个元素为堆顶，依次往后排列。对于任意位置i的元素，其父节点为(i-1)/2，左子节点为2*i+1，右子节点为2*i+2。

2. 插入元素时，先将元素插入到堆的最后一个位置，然后将其与父节点比较，如果比父节点小，则交换位置，直到满足小顶堆的性质。

3. 删除堆顶元素时，将堆顶元素与最后一个元素交换位置，然后删除最后一个元素。再从堆顶开始，与其子节点比较，如果比子节点大，则与较小的子节点交换位置，直到满足小顶堆的性质。

大顶堆的实现：
1. 大顶堆的实现方式与小顶堆基本相同，只是在比较元素大小的时候相反。即插入元素时，如果比父节点大，则交换位置，删除堆顶元素时，如果比子节点小，则与较大的子节点交换位置。
```

### 哈希表如何解决哈希冲突

```
哈希表在插入元素时，如果计算出的哈希值已经有元素存在，就会发生哈希冲突。为了解决这个问题，可以采用开放寻址法和链地址法。开放寻址法是在发生冲突时，不断探测下一个空的位置来插入元素；链地址法则是在哈希表中每个槽位上维护一个链表或者其他数据结构，将哈希值相同的元素放在同一个槽位上。
```

### 浏览器从输入URL到展示页面，经历了哪些过程？

```
1. 浏览器解析url：浏览器会对我们输入的url进行解析，主要将其分为下部分：协议、网络地址、资源路径。其中网络地址指示该连接网络上哪一台计算机，可以是域名或者IP地址，可以包括端口号；协议是从该计算机获取资源的方式，常见的是HTTP，HTTPS，FTP等。不同协议有不同的通讯内容格式；资源路径指示从服务器上需要获取资源的具体路径。

2. 客户端收到你输入的域名地址后，它首先去找本地的hosts文件，检查在该文件中是否有相应的域名、IP对应关系，如果有，则向其IP地址发送请求，如果没有，再去找DNS服务器。

2.1. DNS查询的具体步骤如下：

    从浏览器缓存中查询。浏览器会存储一定时间的DNS记录，操作系统不会告诉浏览器每个DNS记录的保存时限，不同浏览器设置保存时限为一个固定值（不同浏览器情况不同，一般在2-30分钟）。

    从操作系统缓存中查询。如果浏览器中没有包含想要的缓存记录，那浏览器就会发起操作系统请求，继续查询操作系统缓存

    从路由器中查询DNS缓存。请求持续发送到你的路由，它通常会有自己的DNS缓存。
    
    从ISP中查询DNS缓存。下一个被查询地方是ISP缓存DNS的服务器。
    
    域名服务器迭代查询，根据返回的地址逐级向上查询。首先从root域名服务器中查询如.com域名服务器，然后逐步向前查询，.com顶级域名服务器到ruanyifeng的域名服务器。一般来说，.com级别的都已经在缓存中了，所以一般不会进行对root域名服务器的查询。

3. 浏览器获取端口号: http默认80端口，https默认443端口

4. TCP建立连接：三次握手完成，TCP客户端和服务器端成功地建立连接，可以开始传输数据了。

4.1. TCP三次握手的过程如下：

    客户端发送SYN（SEQ=x）报文给服务器端，进入SYN_SEND状态。

    服务器端收到SYN报文，回应一个SYN （SEQ=y）ACK(ACK=x+1）报文，进入SYN_RECV状态。

    客户端收到服务器端的SYN报文，回应一个ACK(ACK=y+1）报文，进入Established状态。

5. 发送HTTP请求

6. 服务器处理请求：服务器端收到请求后的由web服务器（准确说应该是http服务器）处理请求，诸如Apache、Ngnix、IIS等。web服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。

7. 返回响应结果

8. 关闭TCP连接

8.1. TCP四次握手

    某个应用进程首先调用close，称该端执行“主动关闭”（active close）。该端的TCP于是发送一个FIN分节，表示数据发送完毕。
    
    接收到这个FIN的对端执行 “被动关闭”（passive close），这个FIN由TCP确认。
    注意：FIN的接收也作为一个文件结束符（end-of-file）传递给接收端应用进程，放在已排队等候该应用进程接收的任何其他数据之后，因为，FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。
    
    一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN。
    
    接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）确认这个FIN。

9. 浏览器加载解析渲染：当浏览器获得一个html文件时，会“自上而下”加载，并在加载过程中进行解析渲染。

    浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。
    将CSS解析成 CSS Rule Tree 。
    根据DOM树和CSSOM来构造 Rendering Tree。

10. 浏览器发送嵌入在HTML中的对象的请求
```